{"ast":null,"code":"import _classCallCheck from \"E:\\\\3d_web\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"E:\\\\3d_web\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _inherits from \"E:\\\\3d_web\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _createSuper from \"E:\\\\3d_web\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createSuper.js\";\nimport { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils } from 'three';\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nvar PLYLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(PLYLoader, _Loader);\n\n  var _super = _createSuper(PLYLoader);\n\n  function PLYLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, PLYLoader);\n\n    _this = _super.call(this, manager);\n    _this.propertyNameMapping = {};\n    return _this;\n  }\n\n  _createClass(PLYLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"setPropertyNameMapping\",\n    value: function setPropertyNameMapping(mapping) {\n      this.propertyNameMapping = mapping;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function parseHeader(data) {\n        var patternHeader = /^ply([\\s\\S]*)end_header\\r?\\n/;\n        var headerText = '';\n        var headerLength = 0;\n        var result = patternHeader.exec(data);\n\n        if (result !== null) {\n          headerText = result[1];\n          headerLength = new Blob([result[0]]).size;\n        }\n\n        var header = {\n          comments: [],\n          elements: [],\n          headerLength: headerLength,\n          objInfo: ''\n        };\n        var lines = headerText.split('\\n');\n        var currentElement;\n\n        function make_ply_element_property(propertValues, propertyNameMapping) {\n          var property = {\n            type: propertValues[0]\n          };\n\n          if (property.type === 'list') {\n            property.name = propertValues[3];\n            property.countType = propertValues[1];\n            property.itemType = propertValues[2];\n          } else {\n            property.name = propertValues[1];\n          }\n\n          if (property.name in propertyNameMapping) {\n            property.name = propertyNameMapping[property.name];\n          }\n\n          return property;\n        }\n\n        for (var i = 0; i < lines.length; i++) {\n          var line = lines[i];\n          line = line.trim();\n          if (line === '') continue;\n          var lineValues = line.split(/\\s+/);\n          var lineType = lineValues.shift();\n          line = lineValues.join(' ');\n\n          switch (lineType) {\n            case 'format':\n              header.format = lineValues[0];\n              header.version = lineValues[1];\n              break;\n\n            case 'comment':\n              header.comments.push(line);\n              break;\n\n            case 'element':\n              if (currentElement !== undefined) {\n                header.elements.push(currentElement);\n              }\n\n              currentElement = {};\n              currentElement.name = lineValues[0];\n              currentElement.count = parseInt(lineValues[1]);\n              currentElement.properties = [];\n              break;\n\n            case 'property':\n              currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n              break;\n\n            case 'obj_info':\n              header.objInfo = line;\n              break;\n\n            default:\n              console.log('unhandled', lineType, lineValues);\n          }\n        }\n\n        if (currentElement !== undefined) {\n          header.elements.push(currentElement);\n        }\n\n        return header;\n      }\n\n      function parseASCIINumber(n, type) {\n        switch (type) {\n          case 'char':\n          case 'uchar':\n          case 'short':\n          case 'ushort':\n          case 'int':\n          case 'uint':\n          case 'int8':\n          case 'uint8':\n          case 'int16':\n          case 'uint16':\n          case 'int32':\n          case 'uint32':\n            return parseInt(n);\n\n          case 'float':\n          case 'double':\n          case 'float32':\n          case 'float64':\n            return parseFloat(n);\n        }\n      }\n\n      function parseASCIIElement(properties, line) {\n        var values = line.split(/\\s+/);\n        var element = {};\n\n        for (var i = 0; i < properties.length; i++) {\n          if (properties[i].type === 'list') {\n            var list = [];\n            var n = parseASCIINumber(values.shift(), properties[i].countType);\n\n            for (var j = 0; j < n; j++) {\n              list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n            }\n\n            element[properties[i].name] = list;\n          } else {\n            element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n          }\n        }\n\n        return element;\n      }\n\n      function parseASCII(data, header) {\n        // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n        var buffer = {\n          indices: [],\n          vertices: [],\n          normals: [],\n          uvs: [],\n          faceVertexUvs: [],\n          colors: []\n        };\n        var result;\n        var patternBody = /end_header\\s([\\s\\S]*)$/;\n        var body = '';\n\n        if ((result = patternBody.exec(data)) !== null) {\n          body = result[1];\n        }\n\n        var lines = body.split('\\n');\n        var currentElement = 0;\n        var currentElementCount = 0;\n\n        for (var i = 0; i < lines.length; i++) {\n          var line = lines[i];\n          line = line.trim();\n\n          if (line === '') {\n            continue;\n          }\n\n          if (currentElementCount >= header.elements[currentElement].count) {\n            currentElement++;\n            currentElementCount = 0;\n          }\n\n          var element = parseASCIIElement(header.elements[currentElement].properties, line);\n          handleElement(buffer, header.elements[currentElement].name, element);\n          currentElementCount++;\n        }\n\n        return postProcess(buffer);\n      }\n\n      function postProcess(buffer) {\n        var geometry = new BufferGeometry(); // mandatory buffer data\n\n        if (buffer.indices.length > 0) {\n          geometry.setIndex(buffer.indices);\n        }\n\n        geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3)); // optional buffer data\n\n        if (buffer.normals.length > 0) {\n          geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3));\n        }\n\n        if (buffer.uvs.length > 0) {\n          geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2));\n        }\n\n        if (buffer.colors.length > 0) {\n          geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3));\n        }\n\n        if (buffer.faceVertexUvs.length > 0) {\n          geometry = geometry.toNonIndexed();\n          geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n        }\n\n        geometry.computeBoundingSphere();\n        return geometry;\n      }\n\n      function handleElement(buffer, elementName, element) {\n        function findAttrName(names) {\n          for (var i = 0, l = names.length; i < l; i++) {\n            var name = names[i];\n            if (name in element) return name;\n          }\n\n          return null;\n        }\n\n        var attrX = findAttrName(['x', 'px', 'posx']) || 'x';\n        var attrY = findAttrName(['y', 'py', 'posy']) || 'y';\n        var attrZ = findAttrName(['z', 'pz', 'posz']) || 'z';\n        var attrNX = findAttrName(['nx', 'normalx']);\n        var attrNY = findAttrName(['ny', 'normaly']);\n        var attrNZ = findAttrName(['nz', 'normalz']);\n        var attrS = findAttrName(['s', 'u', 'texture_u', 'tx']);\n        var attrT = findAttrName(['t', 'v', 'texture_v', 'ty']);\n        var attrR = findAttrName(['red', 'diffuse_red', 'r', 'diffuse_r']);\n        var attrG = findAttrName(['green', 'diffuse_green', 'g', 'diffuse_g']);\n        var attrB = findAttrName(['blue', 'diffuse_blue', 'b', 'diffuse_b']);\n\n        if (elementName === 'vertex') {\n          buffer.vertices.push(element[attrX], element[attrY], element[attrZ]);\n\n          if (attrNX !== null && attrNY !== null && attrNZ !== null) {\n            buffer.normals.push(element[attrNX], element[attrNY], element[attrNZ]);\n          }\n\n          if (attrS !== null && attrT !== null) {\n            buffer.uvs.push(element[attrS], element[attrT]);\n          }\n\n          if (attrR !== null && attrG !== null && attrB !== null) {\n            buffer.colors.push(element[attrR] / 255.0, element[attrG] / 255.0, element[attrB] / 255.0);\n          }\n        } else if (elementName === 'face') {\n          var vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\n          var texcoord = element.texcoord;\n\n          if (vertex_indices.length === 3) {\n            buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n\n            if (texcoord && texcoord.length === 6) {\n              buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n              buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n              buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n            }\n          } else if (vertex_indices.length === 4) {\n            buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n            buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n          }\n        }\n      }\n\n      function binaryRead(dataview, at, type, little_endian) {\n        switch (type) {\n          // corespondences for non-specific length types here match rply:\n          case 'int8':\n          case 'char':\n            return [dataview.getInt8(at), 1];\n\n          case 'uint8':\n          case 'uchar':\n            return [dataview.getUint8(at), 1];\n\n          case 'int16':\n          case 'short':\n            return [dataview.getInt16(at, little_endian), 2];\n\n          case 'uint16':\n          case 'ushort':\n            return [dataview.getUint16(at, little_endian), 2];\n\n          case 'int32':\n          case 'int':\n            return [dataview.getInt32(at, little_endian), 4];\n\n          case 'uint32':\n          case 'uint':\n            return [dataview.getUint32(at, little_endian), 4];\n\n          case 'float32':\n          case 'float':\n            return [dataview.getFloat32(at, little_endian), 4];\n\n          case 'float64':\n          case 'double':\n            return [dataview.getFloat64(at, little_endian), 8];\n        }\n      }\n\n      function binaryReadElement(dataview, at, properties, little_endian) {\n        var element = {};\n        var result,\n            read = 0;\n\n        for (var i = 0; i < properties.length; i++) {\n          if (properties[i].type === 'list') {\n            var list = [];\n            result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n            var n = result[0];\n            read += result[1];\n\n            for (var j = 0; j < n; j++) {\n              result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n              list.push(result[0]);\n              read += result[1];\n            }\n\n            element[properties[i].name] = list;\n          } else {\n            result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n            element[properties[i].name] = result[0];\n            read += result[1];\n          }\n        }\n\n        return [element, read];\n      }\n\n      function parseBinary(data, header) {\n        var buffer = {\n          indices: [],\n          vertices: [],\n          normals: [],\n          uvs: [],\n          faceVertexUvs: [],\n          colors: []\n        };\n        var little_endian = header.format === 'binary_little_endian';\n        var body = new DataView(data, header.headerLength);\n        var result,\n            loc = 0;\n\n        for (var currentElement = 0; currentElement < header.elements.length; currentElement++) {\n          for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n            result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n            loc += result[1];\n            var element = result[0];\n            handleElement(buffer, header.elements[currentElement].name, element);\n          }\n        }\n\n        return postProcess(buffer);\n      } //\n\n\n      var geometry;\n      var scope = this;\n\n      if (data instanceof ArrayBuffer) {\n        var text = LoaderUtils.decodeText(new Uint8Array(data));\n        var header = parseHeader(text);\n        geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n      } else {\n        geometry = parseASCII(data, parseHeader(data));\n      }\n\n      return geometry;\n    }\n  }]);\n\n  return PLYLoader;\n}(Loader);\n\nexport { PLYLoader };","map":{"version":3,"sources":["E:/3d_web/node_modules/three/examples/jsm/loaders/PLYLoader.js"],"names":["BufferGeometry","FileLoader","Float32BufferAttribute","Loader","LoaderUtils","PLYLoader","manager","propertyNameMapping","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","mapping","data","parseHeader","patternHeader","headerText","headerLength","result","exec","Blob","size","header","comments","elements","objInfo","lines","split","currentElement","make_ply_element_property","propertValues","property","type","name","countType","itemType","i","length","line","trim","lineValues","lineType","shift","join","format","version","push","undefined","count","parseInt","properties","log","parseASCIINumber","n","parseFloat","parseASCIIElement","values","element","list","j","parseASCII","buffer","indices","vertices","normals","uvs","faceVertexUvs","colors","patternBody","body","currentElementCount","handleElement","postProcess","geometry","setIndex","setAttribute","toNonIndexed","computeBoundingSphere","elementName","findAttrName","names","l","attrX","attrY","attrZ","attrNX","attrNY","attrNZ","attrS","attrT","attrR","attrG","attrB","vertex_indices","vertex_index","texcoord","binaryRead","dataview","at","little_endian","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","binaryReadElement","read","parseBinary","DataView","loc","ArrayBuffer","decodeText","Uint8Array"],"mappings":"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","sourcesContent":["import {\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tLoaderUtils\n} from 'three';\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\n\nclass PLYLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.propertyNameMapping = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tsetPropertyNameMapping( mapping ) {\n\n\t\tthis.propertyNameMapping = mapping;\n\n\t}\n\n\tparse( data ) {\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tconst patternHeader = /^ply([\\s\\S]*)end_header\\r?\\n/;\n\t\t\tlet headerText = '';\n\t\t\tlet headerLength = 0;\n\t\t\tconst result = patternHeader.exec( data );\n\n\t\t\tif ( result !== null ) {\n\n\t\t\t\theaderText = result[ 1 ];\n\t\t\t\theaderLength = new Blob( [ result[ 0 ] ] ).size;\n\n\t\t\t}\n\n\t\t\tconst header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength,\n\t\t\t\tobjInfo: ''\n\t\t\t};\n\n\t\t\tconst lines = headerText.split( '\\n' );\n\t\t\tlet currentElement;\n\n\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\n\n\t\t\t\tconst property = { type: propertValues[ 0 ] };\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tproperty.name = propertValues[ 3 ];\n\t\t\t\t\tproperty.countType = propertValues[ 1 ];\n\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertValues[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tlet line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\tconst lineValues = line.split( /\\s+/ );\n\t\t\t\tconst lineType = lineValues.shift();\n\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'obj_info':\n\n\t\t\t\t\t\theader.objInfo = line;\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t}\n\n\t\t\treturn header;\n\n\t\t}\n\n\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\t\treturn parseInt( n );\n\n\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\t\treturn parseFloat( n );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseASCIIElement( properties, line ) {\n\n\t\t\tconst values = line.split( /\\s+/ );\n\n\t\t\tconst element = {};\n\n\t\t\tfor ( let i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tconst list = [];\n\t\t\t\t\tconst n = parseASCIINumber( values.shift(), properties[ i ].countType );\n\n\t\t\t\t\tfor ( let j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t}\n\n\t\tfunction parseASCII( data, header ) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\tconst buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tlet result;\n\n\t\t\tconst patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\tlet body = '';\n\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\tbody = result[ 1 ];\n\n\t\t\t}\n\n\t\t\tconst lines = body.split( '\\n' );\n\t\t\tlet currentElement = 0;\n\t\t\tlet currentElementCount = 0;\n\n\t\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tlet line = lines[ i ];\n\t\t\t\tline = line.trim();\n\t\t\t\tif ( line === '' ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\n\n\t\t\t\t\tcurrentElement ++;\n\t\t\t\t\tcurrentElementCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tconst element = parseASCIIElement( header.elements[ currentElement ].properties, line );\n\n\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\tcurrentElementCount ++;\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\tfunction postProcess( buffer ) {\n\n\t\t\tlet geometry = new BufferGeometry();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif ( buffer.indices.length > 0 ) {\n\n\t\t\t\tgeometry.setIndex( buffer.indices );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( buffer.vertices, 3 ) );\n\n\t\t\t// optional buffer data\n\n\t\t\tif ( buffer.normals.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( buffer.normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.uvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( buffer.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.faceVertexUvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction handleElement( buffer, elementName, element ) {\n\n\t\t\tfunction findAttrName( names ) {\n\n\t\t\t\tfor ( let i = 0, l = names.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst name = names[ i ];\n\n\t\t\t\t\tif ( name in element ) return name;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst attrX = findAttrName( [ 'x', 'px', 'posx' ] ) || 'x';\n\t\t\tconst attrY = findAttrName( [ 'y', 'py', 'posy' ] ) || 'y';\n\t\t\tconst attrZ = findAttrName( [ 'z', 'pz', 'posz' ] ) || 'z';\n\t\t\tconst attrNX = findAttrName( [ 'nx', 'normalx' ] );\n\t\t\tconst attrNY = findAttrName( [ 'ny', 'normaly' ] );\n\t\t\tconst attrNZ = findAttrName( [ 'nz', 'normalz' ] );\n\t\t\tconst attrS = findAttrName( [ 's', 'u', 'texture_u', 'tx' ] );\n\t\t\tconst attrT = findAttrName( [ 't', 'v', 'texture_v', 'ty' ] );\n\t\t\tconst attrR = findAttrName( [ 'red', 'diffuse_red', 'r', 'diffuse_r' ] );\n\t\t\tconst attrG = findAttrName( [ 'green', 'diffuse_green', 'g', 'diffuse_g' ] );\n\t\t\tconst attrB = findAttrName( [ 'blue', 'diffuse_blue', 'b', 'diffuse_b' ] );\n\n\t\t\tif ( elementName === 'vertex' ) {\n\n\t\t\t\tbuffer.vertices.push( element[ attrX ], element[ attrY ], element[ attrZ ] );\n\n\t\t\t\tif ( attrNX !== null && attrNY !== null && attrNZ !== null ) {\n\n\t\t\t\t\tbuffer.normals.push( element[ attrNX ], element[ attrNY ], element[ attrNZ ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attrS !== null && attrT !== null ) {\n\n\t\t\t\t\tbuffer.uvs.push( element[ attrS ], element[ attrT ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attrR !== null && attrG !== null && attrB !== null ) {\n\n\t\t\t\t\tbuffer.colors.push( element[ attrR ] / 255.0, element[ attrG ] / 255.0, element[ attrB ] / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\tconst vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\t\t\t\tconst texcoord = element.texcoord;\n\n\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t\tif ( texcoord && texcoord.length === 6 ) {\n\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryRead( dataview, at, type, little_endian ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\n\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\n\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\n\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\n\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\n\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\n\n\t\t\tconst element = {};\n\t\t\tlet result, read = 0;\n\n\t\t\tfor ( let i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tconst list = [];\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\n\t\t\t\t\tconst n = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\tfor ( let j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\n\t\t\t\t\t\tlist.push( result[ 0 ] );\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\n\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn [ element, read ];\n\n\t\t}\n\n\t\tfunction parseBinary( data, header ) {\n\n\t\t\tconst buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tconst little_endian = ( header.format === 'binary_little_endian' );\n\t\t\tconst body = new DataView( data, header.headerLength );\n\t\t\tlet result, loc = 0;\n\n\t\t\tfor ( let currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\tfor ( let currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\n\n\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\n\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\tconst element = result[ 0 ];\n\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\t//\n\n\t\tlet geometry;\n\t\tconst scope = this;\n\n\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst text = LoaderUtils.decodeText( new Uint8Array( data ) );\n\t\t\tconst header = parseHeader( text );\n\n\t\t\tgeometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );\n\n\t\t} else {\n\n\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nexport { PLYLoader };\n"]},"metadata":{},"sourceType":"module"}